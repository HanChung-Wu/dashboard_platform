# AI Prompt
## Copilot å°ˆæ¡ˆçš„é–‹å§‹
æå•
```md
é€™æ˜¯æˆ‘çš„æ–°å°ˆæ¡ˆçš„ä¾è³´ç‰ˆæœ¬
===
"dependencies": {
"@emotion/react": "^11.14.0",
"@emotion/styled": "^11.14.1",
"@mui/icons-material": "^7.3.1",
"@mui/material": "^7.3.1",
"react": "^19.1.1",
"react-dom": "^19.1.1",
"react-router-dom": "^7.8.0",
"zustand": "^5.0.7"
},
"devDependencies": {
"@eslint/js": "^9.33.0",
"@types/react": "^19.1.10",
"@types/react-dom": "^19.1.7",
"@vitejs/plugin-react": "^5.0.0",
"eslint": "^9.33.0",
"eslint-config-prettier": "^10.1.8",
"eslint-plugin-react": "^7.37.5",
"eslint-plugin-react-hooks": "^5.2.0",
"eslint-plugin-react-refresh": "^0.4.20",
"globals": "^16.3.0",
"prettier": "^3.6.2",
"typescript": "~5.8.3",
"typescript-eslint": "^8.39.1",
"vite": "^7.1.2"
}
===
æˆ‘å¸Œæœ›æ­¤å°ˆæ¡ˆç”¨ä¾†ç®¡ç†è³‡æ–™è¡¨ã€è‡ªè¨‚çµ±è¨ˆåœ–è¡¨ã€çµ„è£å„€è¡¨æ¿ï¼Œä¸¦æä¾›ä¸Šå‚³è³‡æ–™è¡¨æ ¼ã€çµ±è¨ˆåœ–è¡¨è¨­å®šã€å„€è¡¨æ¿è¨­å®šï¼Œä»¥åŠä¸‹è¼‰å–®ç¨çµ±è¨ˆåœ–è¡¨ã€å„€è¡¨æ¿ã€çµ±è¨ˆåœ–è¡¨è¨­å®šã€å„€è¡¨æ¿è¨­å®š
```
å›ç­”
```md
æ„Ÿè¬ä½ æä¾›é€™ä»½ä¾è³´æ¸…å–®èˆ‡å°ˆæ¡ˆç›®æ¨™ï¼å¾ä½ æè¿°çš„åŠŸèƒ½ä¾†çœ‹ï¼Œä½ çš„å°ˆæ¡ˆæ˜¯ä¸€å€‹è³‡æ–™è¦–è¦ºåŒ–èˆ‡å„€è¡¨æ¿ç®¡ç†å¹³å°ï¼Œå…·å‚™ä»¥ä¸‹æ ¸å¿ƒåŠŸèƒ½ï¼š

- è³‡æ–™è¡¨ä¸Šå‚³èˆ‡ç®¡ç†
- çµ±è¨ˆåœ–è¡¨çš„è‡ªè¨‚èˆ‡è¨­å®š
- å„€è¡¨æ¿çš„çµ„è£èˆ‡è¨­å®š
- ä¸‹è¼‰åŠŸèƒ½ï¼šåœ–è¡¨ã€å„€è¡¨æ¿èˆ‡å…¶è¨­å®š

ç›®å‰çš„ä¾è³´ç‰ˆæœ¬æ•´é«”ä¾†èªªæ˜¯ç¾ä»£ä¸”ç©©å®šçš„ï¼Œä»¥ä¸‹æ˜¯ä¸€äº›é‡å°ä½ çš„éœ€æ±‚çš„å»ºè­°èˆ‡å¾ŒçºŒå¯è€ƒæ…®çš„å¥—ä»¶æˆ–æ¶æ§‹æ–¹å‘ï¼š

âœ… ç›®å‰ä¾è³´çš„å„ªé»
- React 19 + Vite 7ï¼šéå¸¸ç¾ä»£çš„é–‹ç™¼ç’°å¢ƒï¼Œæ•ˆèƒ½ä½³ã€‚
- MUI + Emotionï¼šé©åˆå¿«é€Ÿå»ºç«‹ç¾è§€çš„ UIã€‚
- Zustandï¼šè¼•é‡çš„ç‹€æ…‹ç®¡ç†ï¼Œé©åˆä¸­å°å‹æ‡‰ç”¨ã€‚
- React Router v7ï¼šæ”¯æ´å·¢ç‹€è·¯ç”±èˆ‡æ‡¶åŠ è¼‰ï¼Œé©åˆå„€è¡¨æ¿å‹æ‡‰ç”¨ã€‚
- ESLint + Prettier + TypeScriptï¼šè‰¯å¥½çš„é–‹ç™¼é«”é©—èˆ‡å‹åˆ¥å®‰å…¨ã€‚

ğŸ”§ å»ºè­°è£œå……çš„å¥—ä»¶ï¼ˆä¾åŠŸèƒ½éœ€æ±‚ï¼‰
| åŠŸèƒ½               | å»ºè­°å¥—ä»¶                      | èªªæ˜                        |
| ------------------ | ----------------------------- | --------------------------- |
| è³‡æ–™è¡¨ä¸Šå‚³èˆ‡è§£æ   | papaparse                     | è™•ç† CSV/TSV æª”æ¡ˆä¸Šå‚³èˆ‡è§£æ |
| åœ–è¡¨ç¹ªè£½           | recharts æˆ– echarts-for-react | å»ºç«‹äº’å‹•å¼çµ±è¨ˆåœ–è¡¨          |
| å„€è¡¨æ¿æ‹–æ‹‰çµ„è£     | react-grid-layout             | æ”¯æ´æ‹–æ‹‰å¼å„€è¡¨æ¿é…ç½®        |
| è¨­å®šå„²å­˜èˆ‡åŒ¯å‡º     | file-saver, jszip             | åŒ¯å‡º JSON è¨­å®šæˆ–æ‰“åŒ…ä¸‹è¼‰    |
| è¡¨å–®è¨­å®š UI        | react-hook-form + zod         | å»ºç«‹åœ–è¡¨èˆ‡å„€è¡¨æ¿è¨­å®šè¡¨å–®    |
| å¤šèªç³»æ”¯æ´ï¼ˆå¦‚éœ€ï¼‰ | react-i18next                 | è‹¥æœªä¾†è€ƒæ…®åœ‹éš›åŒ–            |

ğŸ§© æ¶æ§‹å»ºè­°
ä½ å¯ä»¥è€ƒæ…®å°‡å°ˆæ¡ˆæ¨¡çµ„åŒ–ç‚ºä»¥ä¸‹å¹¾å€‹å€å¡Šï¼š

- è³‡æ–™ç®¡ç†æ¨¡çµ„ï¼šä¸Šå‚³ã€è§£æã€å„²å­˜è³‡æ–™è¡¨
- åœ–è¡¨è¨­å®šæ¨¡çµ„ï¼šé¸æ“‡è³‡æ–™æ¬„ä½ã€åœ–è¡¨é¡å‹ã€æ¨£å¼è¨­å®š
- å„€è¡¨æ¿æ¨¡çµ„ï¼šæ‹–æ‹‰å¼é…ç½®ã€å„²å­˜èˆ‡è¼‰å…¥å„€è¡¨æ¿
- ä¸‹è¼‰æ¨¡çµ„ï¼šåŒ¯å‡ºåœ–è¡¨åœ–ç‰‡ã€è¨­å®š JSONã€æ•´é«”å„€è¡¨æ¿

å¦‚æœä½ å¸Œæœ›æˆ‘å¹«ä½ å»ºç«‹ä¸€å€‹åˆå§‹çš„å°ˆæ¡ˆçµæ§‹æˆ–æ˜¯è¨­å®šæŸå€‹åŠŸèƒ½æ¨¡çµ„ï¼ˆä¾‹å¦‚åœ–è¡¨è¨­å®šæˆ–å„€è¡¨æ¿çµ„è£ï¼‰ï¼Œæˆ‘å¯ä»¥ä¸€æ­¥æ­¥å¸¶ä½ å®Œæˆã€‚ä½ æƒ³å…ˆå¾å“ªå€‹éƒ¨åˆ†é–‹å§‹å‘¢ï¼Ÿä¾‹å¦‚ï¼š

- å»ºç«‹åœ–è¡¨è¨­å®š UIï¼Ÿ
- å¯¦ä½œè³‡æ–™è¡¨ä¸Šå‚³èˆ‡è§£æï¼Ÿ
- å„€è¡¨æ¿æ‹–æ‹‰å¼é…ç½®ï¼Ÿ
- æˆ–æ˜¯å…ˆå»ºç«‹æ•´é«”çš„é é¢è·¯ç”±æ¶æ§‹ï¼Ÿ

ä½ èªªäº†ç®—ï¼ğŸ’¡
```

## Copilot ä¸‹æ¬¡æå•å»ºè­°
```md
å…ˆæš«åœä¸€ä¸‹é€²åº¦ã€‚
å¦‚æœæˆ‘ä¸‹æ¬¡è¦å‘AI(ä¾‹å¦‚ ä½ )æå•ï¼Œä½†ä»–ä¸€ç„¡æ‰€çŸ¥ï¼Œæˆ‘æ‡‰è©²è¦çµ¦å‡ºæ€æ¨£çš„ prompt ä½œç‚ºé–‹é ­æç¤ºï¼Œæœƒæœ‰æ›´å¥½çš„æ•ˆæœã€‚
å¦‚æœå¯ä»¥è«‹å¥—ç”¨å°ˆæ¥­çš„ prompt æ¡†æ¶
```
```md
é€™æ˜¯ä¸€å€‹éå¸¸æ£’çš„å•é¡Œï¼å¦‚æœä½ å¸Œæœ›åœ¨æœªä¾†å‘ AIï¼ˆåƒæˆ‘ï¼‰æå•æ™‚ï¼Œå³ä½¿æˆ‘å€‘å°æŸå€‹ä¸»é¡Œã€Œä¸€ç„¡æ‰€çŸ¥ã€ï¼Œä¹Ÿèƒ½å¹«ä½ ç”¢å‡ºæ›´æº–ç¢ºã€æ›´æœ‰åƒ¹å€¼çš„å›æ‡‰ï¼Œé‚£éº¼ä½ å¯ä»¥ä½¿ç”¨ä¸€å€‹å°ˆæ¥­çš„ Prompt æ¡†æ¶ä¾†å¼•å°æˆ‘å€‘ç†è§£ä½ çš„æ„åœ–èˆ‡èƒŒæ™¯ã€‚

ğŸ¯ å°ˆæ¥­ Prompt æ¡†æ¶ï¼šRICCE
é€™æ˜¯ä¸€å€‹æˆ‘æ¨è–¦çš„æ¡†æ¶ï¼Œé©åˆæŠ€è¡“ã€ç”¢å“ã€è¨­è¨ˆã€ç ”ç©¶ç­‰é ˜åŸŸçš„æå•ï¼š

| é …ç›®                | èªªæ˜                                                                                         |
| ------------------- | -------------------------------------------------------------------------------------------- |
| Roleï¼ˆè§’è‰²ï¼‰        | æŒ‡å®š AI æ‰®æ¼”çš„è§’è‰²ï¼Œä¾‹å¦‚ã€Œä½ æ˜¯ä¸€ä½è³‡æ·±å‰ç«¯å·¥ç¨‹å¸«ã€                                           |
| Intentï¼ˆæ„åœ–ï¼‰      | èªªæ˜ä½ å¸Œæœ›é”æˆçš„ç›®æ¨™ï¼Œä¾‹å¦‚ã€Œæˆ‘æƒ³å»ºç«‹ä¸€å€‹å¯è¦–åŒ–å„€è¡¨æ¿ã€                                       |
| Contextï¼ˆèƒŒæ™¯ï¼‰     | æä¾›ç›®å‰çš„ç‹€æ³ã€å·²æœ‰çš„è³‡æ–™ã€é™åˆ¶æ¢ä»¶ç­‰                                                       |
| Constraintsï¼ˆé™åˆ¶ï¼‰ | æŒ‡å®šæŠ€è¡“é™åˆ¶ã€æ™‚é–“ã€æ¡†æ¶ã€èªè¨€ç­‰                                                             |
| Expectationï¼ˆæœŸæœ›ï¼‰ | èªªæ˜ä½ å¸Œæœ› AI å›è¦†çš„å½¢å¼ï¼Œä¾‹å¦‚ã€Œè«‹ç”¨ TypeScript + React å¯¦ä½œç¯„ä¾‹ã€æˆ–ã€Œè«‹åˆ—å‡ºä¸‰ç¨®è§£æ³•ä¸¦æ¯”è¼ƒã€ |

ğŸ§  ç¯„ä¾‹ Promptï¼ˆä»¥ä½ ç›®å‰çš„å°ˆæ¡ˆç‚ºä¾‹ï¼‰
ä½ æ˜¯ä¸€ä½è³‡æ·± React å·¥ç¨‹å¸«ã€‚æˆ‘æ­£åœ¨é–‹ç™¼ä¸€å€‹è³‡æ–™è¦–è¦ºåŒ–å„€è¡¨æ¿ï¼Œä½¿ç”¨ Vite + React + MUI + Zustandã€‚ç›®å‰æˆ‘å·²å®ŒæˆåŸºæœ¬ UI æ¶æ§‹ï¼Œæ¥ä¸‹ä¾†æƒ³å¯¦ä½œåœ–è¡¨è¨­å®šåŠŸèƒ½ã€‚è«‹æ ¹æ“šæˆ‘æä¾›çš„è³‡æ–™çµæ§‹ï¼Œå¹«æˆ‘è¨­è¨ˆä¸€å€‹å¯å‹•æ…‹è¨­å®šåœ–è¡¨é¡å‹ã€è³‡æ–™ä¾†æºèˆ‡æ¨£å¼çš„å…ƒä»¶ï¼Œä¸¦ç”¨ TypeScript æ’°å¯«ã€‚è«‹æä¾›å…ƒä»¶æ¶æ§‹ã€ç‹€æ…‹ç®¡ç†æ–¹å¼èˆ‡ UI å¯¦ä½œå»ºè­°ã€‚

ğŸ§© æå•æ™‚çš„æç¤ºèªå¥ï¼ˆä½ å¯ä»¥å¥—ç”¨ï¼‰
ã€Œä½ æ˜¯ä¸€ä½ç†Ÿæ‚‰ ___ æŠ€è¡“çš„å·¥ç¨‹å¸«ï¼Œè«‹æ ¹æ“šä»¥ä¸‹èƒŒæ™¯å”åŠ©æˆ‘è§£æ±ºå•é¡Œã€‚ã€
ã€Œæˆ‘å¸Œæœ›é”æˆ ___ï¼Œç›®å‰çš„ç‹€æ³æ˜¯ ___ï¼Œè«‹æ ¹æ“šé€™äº›æ¢ä»¶æä¾›å»ºè­°æˆ–ç¯„ä¾‹ã€‚ã€
ã€Œè«‹ç”¨ ___ æŠ€è¡“å¯¦ä½œï¼Œä¸¦è€ƒæ…®ä»¥ä¸‹é™åˆ¶ï¼š___ã€‚ã€
ã€Œè«‹åˆ—å‡º ___ çš„ä¸‰ç¨®ä½œæ³•ï¼Œä¸¦æ¯”è¼ƒå„ªç¼ºé»ã€‚ã€
å¦‚æœä½ æƒ³ï¼Œæˆ‘å¯ä»¥å¹«ä½ å»ºç«‹ä¸€å€‹å¯é‡è¤‡ä½¿ç”¨çš„ Prompt æ¨¡æ¿ï¼Œè®“ä½ æœªä¾†åªè¦å¡«ç©ºå°±èƒ½å¿«é€Ÿæå•ã€‚ä½ æƒ³è¦é€™æ¨£çš„æ¨¡æ¿å—ï¼Ÿé‚„æ˜¯æƒ³é‡å°æŸå€‹é ˜åŸŸï¼ˆä¾‹å¦‚ Reactã€è³‡æ–™è¦–è¦ºåŒ–ã€AI å·¥å…·æ•´åˆï¼‰å»ºç«‹å°ˆå±¬æå•æ ¼å¼ï¼Ÿ
```

## ChatGPT å°ˆæ¡ˆè¦åŠƒ
> å¾ŒçºŒæ²’æœ‰æå•è€… çš†ç‚ºæå•ã€Œå¥½ã€

æå•
```
ä½ æ˜¯ä¸€ä½è³‡æ·± React å·¥ç¨‹å¸«ã€‚æˆ‘æ­£åœ¨é–‹ç™¼ä¸€å€‹è³‡æ–™è¦–è¦ºåŒ–å„€è¡¨æ¿ï¼Œä½¿ç”¨ Vite + React + MUI + Zustandã€‚ç›®å‰æˆ‘å·²å®ŒæˆåŸºæœ¬ UI æ¶æ§‹ï¼Œæ¥ä¸‹ä¾†æƒ³å¯¦ä½œåœ–è¡¨è¨­å®šåŠŸèƒ½ã€‚è«‹æ ¹æ“šæˆ‘æä¾›çš„è³‡æ–™çµæ§‹ï¼Œå¹«æˆ‘è¨­è¨ˆä¸€å€‹å¯å‹•æ…‹è¨­å®šåœ–è¡¨é¡å‹ã€è³‡æ–™ä¾†æºèˆ‡æ¨£å¼çš„å…ƒä»¶ï¼Œä¸¦ç”¨ TypeScript æ’°å¯«ã€‚è«‹æä¾›å…ƒä»¶æ¶æ§‹ã€ç‹€æ…‹ç®¡ç†æ–¹å¼èˆ‡ UI å¯¦ä½œå»ºè­°ã€‚
```
## ChatGPT å›ç­” å°ˆæ¡ˆè¦åŠƒ

å¥½çš„ ğŸ‘ è®“æˆ‘å¹«ä½ è¦åŠƒã€‚ä½ ç›®å‰çš„æŠ€è¡“æ£§æ˜¯ **Vite + React + MUI + Zustand**ï¼Œéœ€æ±‚æ˜¯åšä¸€å€‹ã€Œå¯å‹•æ…‹è¨­å®šåœ–è¡¨çš„è¨­å®šé¢æ¿å…ƒä»¶ã€ï¼ŒåŒ…å« **åœ–è¡¨é¡å‹ (chart type)**ã€**è³‡æ–™ä¾†æº (data source)** å’Œ **æ¨£å¼ (style)**ã€‚æˆ‘æœƒå…ˆæ‹†è§£éœ€æ±‚ï¼Œå†çµ¦ä½ ï¼š

1. **ç‹€æ…‹çµæ§‹ (TypeScript interface)**
2. **Zustand Store è¨­è¨ˆ**
3. **React å…ƒä»¶æ¶æ§‹**
4. **MUI UI å¯¦ä½œå»ºè­°**

---

### 1. è³‡æ–™çµæ§‹ (TypeScript Interfaces)

å‡è¨­ä½ çš„åœ–è¡¨éœ€è¦æœ€åŸºæœ¬çš„è¨­å®šï¼š

```ts
// åœ–è¡¨é¡å‹
export type ChartType = "line" | "bar" | "pie" | "scatter";

// è³‡æ–™ä¾†æº (å¯ä»¥å†æ“´å……)
export interface DataSource {
  id: string;
  label: string;
  url: string; // or local dataset reference
}

// æ¨£å¼è¨­å®š
export interface ChartStyle {
  colorScheme: string; // ex: "default" | "dark" | "pastel"
  showLegend: boolean;
  showGrid: boolean;
}

// æ•´é«”è¨­å®š
export interface ChartConfig {
  id: string;
  type: ChartType;
  dataSourceId: string;
  style: ChartStyle;
}
```

---

### 2. Zustand Store è¨­è¨ˆ

æˆ‘å€‘éœ€è¦ä¸€å€‹å…¨åŸŸ store ä¾†å­˜æ”¾ **ç›®å‰çš„æ‰€æœ‰åœ–è¡¨è¨­å®š**ï¼Œä»¥åŠæ“ä½œå‡½æ•¸ã€‚

```ts
import { create } from "zustand";
import { ChartConfig, ChartType, ChartStyle } from "./types";

interface ChartStore {
  charts: ChartConfig[];
  addChart: (config: ChartConfig) => void;
  updateChart: (id: string, updates: Partial<ChartConfig>) => void;
  removeChart: (id: string) => void;
}

export const useChartStore = create<ChartStore>((set) => ({
  charts: [],
  addChart: (config) =>
    set((state) => ({ charts: [...state.charts, config] })),
  updateChart: (id, updates) =>
    set((state) => ({
      charts: state.charts.map((chart) =>
        chart.id === id ? { ...chart, ...updates } : chart
      ),
    })),
  removeChart: (id) =>
    set((state) => ({
      charts: state.charts.filter((chart) => chart.id !== id),
    })),
}));
```

---

### 3. React å…ƒä»¶æ¶æ§‹

æˆ‘å»ºè­°æ‹†æˆå¹¾å€‹å…ƒä»¶ï¼Œæ–¹ä¾¿é‡ç”¨ï¼š

```
/components
  ChartConfigPanel.tsx   <-- ä¸»è¨­å®šé¢æ¿ (åŒ…å«é¡å‹/è³‡æ–™ä¾†æº/æ¨£å¼)
  ChartTypeSelector.tsx  <-- ä¸‹æ‹‰é¸å–®æˆ– Tab é¸åœ–è¡¨é¡å‹
  DataSourceSelector.tsx <-- é¸æ“‡è³‡æ–™ä¾†æº
  StyleConfigurator.tsx  <-- åˆ‡æ›é¡è‰²/legend/grid
```

ç¯„ä¾‹ `ChartConfigPanel.tsx`ï¼š

```tsx
import React from "react";
import { useChartStore } from "../store/chartStore";
import { ChartConfig } from "../types";
import { ChartTypeSelector } from "./ChartTypeSelector";
import { DataSourceSelector } from "./DataSourceSelector";
import { StyleConfigurator } from "./StyleConfigurator";
import { Card, CardContent, Typography } from "@mui/material";

interface Props {
  chartId: string;
}

export const ChartConfigPanel: React.FC<Props> = ({ chartId }) => {
  const chart = useChartStore((s) =>
    s.charts.find((c) => c.id === chartId)
  );
  const updateChart = useChartStore((s) => s.updateChart);

  if (!chart) return null;

  return (
    <Card variant="outlined" sx={{ borderRadius: 2, mb: 2 }}>
      <CardContent>
        <Typography variant="h6" gutterBottom>
          åœ–è¡¨è¨­å®š
        </Typography>

        <ChartTypeSelector
          value={chart.type}
          onChange={(type) => updateChart(chartId, { type })}
        />

        <DataSourceSelector
          value={chart.dataSourceId}
          onChange={(ds) => updateChart(chartId, { dataSourceId: ds })}
        />

        <StyleConfigurator
          style={chart.style}
          onChange={(style) => updateChart(chartId, { style })}
        />
      </CardContent>
    </Card>
  );
};
```

---

### 4. MUI UI å¯¦ä½œå»ºè­°

#### (1) ChartTypeSelector

ç”¨ **MUI Tabs** æˆ– **Select** ä¸‹æ‹‰é¸å–®ï¼š

```tsx
<Select
  label="åœ–è¡¨é¡å‹"
  value={value}
  onChange={(e) => onChange(e.target.value as ChartType)}
>
  <MenuItem value="line">æŠ˜ç·šåœ–</MenuItem>
  <MenuItem value="bar">é•·æ¢åœ–</MenuItem>
  <MenuItem value="pie">åœ“é¤…åœ–</MenuItem>
  <MenuItem value="scatter">æ•£é»åœ–</MenuItem>
</Select>
```

---

#### (2) DataSourceSelector

ç”¨ **Autocomplete** æˆ– **Select**ï¼š

```tsx
<Autocomplete
  options={dataSources}
  getOptionLabel={(o) => o.label}
  value={dataSources.find((d) => d.id === value) || null}
  onChange={(_, newVal) => onChange(newVal?.id || "")}
  renderInput={(params) => <TextField {...params} label="è³‡æ–™ä¾†æº" />}
/>
```

---

#### (3) StyleConfigurator

ç”¨ **Switch + RadioGroup**ï¼š

```tsx
<FormControlLabel
  control={
    <Switch
      checked={style.showLegend}
      onChange={(e) =>
        onChange({ ...style, showLegend: e.target.checked })
      }
    />
  }
  label="é¡¯ç¤ºåœ–ä¾‹"
/>

<FormControlLabel
  control={
    <Switch
      checked={style.showGrid}
      onChange={(e) =>
        onChange({ ...style, showGrid: e.target.checked })
      }
    />
  }
  label="é¡¯ç¤ºæ ¼ç·š"
/>

<RadioGroup
  value={style.colorScheme}
  onChange={(e) => onChange({ ...style, colorScheme: e.target.value })}
>
  <FormControlLabel value="default" control={<Radio />} label="é è¨­" />
  <FormControlLabel value="dark" control={<Radio />} label="æ·±è‰²" />
  <FormControlLabel value="pastel" control={<Radio />} label="æŸ”å’Œ" />
</RadioGroup>
```

---

âœ… é€™æ¨£çš„è¨­è¨ˆï¼š

* **Zustand** ç®¡ç†å¤šå€‹åœ–è¡¨çš„è¨­å®š
* **ChartConfigPanel** åšå–®ä¸€åœ–è¡¨çš„è¨­å®š
* **MUI å…ƒä»¶** åˆ†é¡æ¸…æ¥šï¼ŒUI ç›´è¦º

---

è¦ä¸è¦æˆ‘å¹«ä½ ç›´æ¥è£œä¸€å€‹ **å®Œæ•´ç¯„ä¾‹å°ˆæ¡ˆçµæ§‹ (åŒ…å« App.tsx + store + components)**ï¼Œé€™æ¨£ä½ å¯ä»¥ç›´æ¥è·‘èµ·ä¾†ï¼Ÿ

## ChatGPT å›ç­” å°ˆæ¡ˆçµæ§‹

å¤ªå¥½äº† ğŸ™Œ é‚£æˆ‘ä¾†å¹«ä½ çµ„ä¸€å€‹ **å¯ç›´æ¥è·‘çš„å®Œæ•´ç¯„ä¾‹å°ˆæ¡ˆçµæ§‹**ã€‚é€™å€‹ä¾‹å­æœƒç”¨ **Vite + React + TypeScript + MUI + Zustand**ï¼ŒåŒ…å«åŸºæœ¬çš„åœ–è¡¨è¨­å®šé¢æ¿ï¼Œå¯ä»¥æ–°å¢ / ä¿®æ”¹åœ–è¡¨è¨­å®šã€‚

---

### ğŸ“‚ å°ˆæ¡ˆçµæ§‹å»ºè­°

```
src/
 â”œâ”€ main.tsx
 â”œâ”€ App.tsx
 â”œâ”€ types.ts
 â”œâ”€ store/
 â”‚   â””â”€ chartStore.ts
 â”œâ”€ components/
 â”‚   â”œâ”€ ChartConfigPanel.tsx
 â”‚   â”œâ”€ ChartTypeSelector.tsx
 â”‚   â”œâ”€ DataSourceSelector.tsx
 â”‚   â””â”€ StyleConfigurator.tsx
```

---

### 1. `types.ts`

```ts
export type ChartType = "line" | "bar" | "pie" | "scatter";

export interface DataSource {
  id: string;
  label: string;
  url: string;
}

export interface ChartStyle {
  colorScheme: string;
  showLegend: boolean;
  showGrid: boolean;
}

export interface ChartConfig {
  id: string;
  type: ChartType;
  dataSourceId: string;
  style: ChartStyle;
}
```

---

### 2. `store/chartStore.ts`

```ts
import { create } from "zustand";
import { ChartConfig } from "../types";

interface ChartStore {
  charts: ChartConfig[];
  addChart: (config: ChartConfig) => void;
  updateChart: (id: string, updates: Partial<ChartConfig>) => void;
  removeChart: (id: string) => void;
}

export const useChartStore = create<ChartStore>((set) => ({
  charts: [],
  addChart: (config) =>
    set((state) => ({ charts: [...state.charts, config] })),
  updateChart: (id, updates) =>
    set((state) => ({
      charts: state.charts.map((chart) =>
        chart.id === id ? { ...chart, ...updates } : chart
      ),
    })),
  removeChart: (id) =>
    set((state) => ({
      charts: state.charts.filter((chart) => chart.id !== id),
    })),
}));
```

---

### 3. `components/ChartTypeSelector.tsx`

```tsx
import React from "react";
import { MenuItem, Select, InputLabel, FormControl } from "@mui/material";
import { ChartType } from "../types";

interface Props {
  value: ChartType;
  onChange: (value: ChartType) => void;
}

export const ChartTypeSelector: React.FC<Props> = ({ value, onChange }) => {
  return (
    <FormControl fullWidth margin="normal">
      <InputLabel>åœ–è¡¨é¡å‹</InputLabel>
      <Select
        value={value}
        label="åœ–è¡¨é¡å‹"
        onChange={(e) => onChange(e.target.value as ChartType)}
      >
        <MenuItem value="line">æŠ˜ç·šåœ–</MenuItem>
        <MenuItem value="bar">é•·æ¢åœ–</MenuItem>
        <MenuItem value="pie">åœ“é¤…åœ–</MenuItem>
        <MenuItem value="scatter">æ•£é»åœ–</MenuItem>
      </Select>
    </FormControl>
  );
};
```

---

### 4. `components/DataSourceSelector.tsx`

```tsx
import React from "react";
import { Autocomplete, TextField } from "@mui/material";
import { DataSource } from "../types";

interface Props {
  value: string;
  onChange: (value: string) => void;
  dataSources: DataSource[];
}

export const DataSourceSelector: React.FC<Props> = ({
  value,
  onChange,
  dataSources,
}) => {
  return (
    <Autocomplete
      options={dataSources}
      getOptionLabel={(o) => o.label}
      value={dataSources.find((d) => d.id === value) || null}
      onChange={(_, newVal) => onChange(newVal?.id || "")}
      renderInput={(params) => <TextField {...params} label="è³‡æ–™ä¾†æº" />}
    />
  );
};
```

---

### 5. `components/StyleConfigurator.tsx`

```tsx
import React from "react";
import {
  FormControlLabel,
  Switch,
  RadioGroup,
  Radio,
  Typography,
} from "@mui/material";
import { ChartStyle } from "../types";

interface Props {
  style: ChartStyle;
  onChange: (style: ChartStyle) => void;
}

export const StyleConfigurator: React.FC<Props> = ({ style, onChange }) => {
  return (
    <div style={{ marginTop: "1rem" }}>
      <Typography variant="subtitle1">æ¨£å¼è¨­å®š</Typography>

      <FormControlLabel
        control={
          <Switch
            checked={style.showLegend}
            onChange={(e) =>
              onChange({ ...style, showLegend: e.target.checked })
            }
          />
        }
        label="é¡¯ç¤ºåœ–ä¾‹"
      />

      <FormControlLabel
        control={
          <Switch
            checked={style.showGrid}
            onChange={(e) =>
              onChange({ ...style, showGrid: e.target.checked })
            }
          />
        }
        label="é¡¯ç¤ºæ ¼ç·š"
      />

      <Typography variant="body2" sx={{ mt: 1 }}>
        è‰²å½©ä¸»é¡Œ
      </Typography>
      <RadioGroup
        row
        value={style.colorScheme}
        onChange={(e) => onChange({ ...style, colorScheme: e.target.value })}
      >
        <FormControlLabel value="default" control={<Radio />} label="é è¨­" />
        <FormControlLabel value="dark" control={<Radio />} label="æ·±è‰²" />
        <FormControlLabel value="pastel" control={<Radio />} label="æŸ”å’Œ" />
      </RadioGroup>
    </div>
  );
};
```

---

### 6. `components/ChartConfigPanel.tsx`

```tsx
import React from "react";
import { Card, CardContent, Typography } from "@mui/material";
import { useChartStore } from "../store/chartStore";
import { ChartTypeSelector } from "./ChartTypeSelector";
import { DataSourceSelector } from "./DataSourceSelector";
import { StyleConfigurator } from "./StyleConfigurator";
import { DataSource } from "../types";

interface Props {
  chartId: string;
  dataSources: DataSource[];
}

export const ChartConfigPanel: React.FC<Props> = ({ chartId, dataSources }) => {
  const chart = useChartStore((s) =>
    s.charts.find((c) => c.id === chartId)
  );
  const updateChart = useChartStore((s) => s.updateChart);

  if (!chart) return null;

  return (
    <Card variant="outlined" sx={{ borderRadius: 2, mb: 2 }}>
      <CardContent>
        <Typography variant="h6" gutterBottom>
          åœ–è¡¨è¨­å®š
        </Typography>

        <ChartTypeSelector
          value={chart.type}
          onChange={(type) => updateChart(chartId, { type })}
        />

        <DataSourceSelector
          value={chart.dataSourceId}
          dataSources={dataSources}
          onChange={(ds) => updateChart(chartId, { dataSourceId: ds })}
        />

        <StyleConfigurator
          style={chart.style}
          onChange={(style) => updateChart(chartId, { style })}
        />
      </CardContent>
    </Card>
  );
};
```

---

### 7. `App.tsx`

```tsx
import React from "react";
import { Button, Container, Typography } from "@mui/material";
import { useChartStore } from "./store/chartStore";
import { ChartConfigPanel } from "./components/ChartConfigPanel";
import { v4 as uuidv4 } from "uuid";

const mockDataSources = [
  { id: "1", label: "Sales Data", url: "/data/sales.json" },
  { id: "2", label: "User Growth", url: "/data/users.json" },
];

function App() {
  const charts = useChartStore((s) => s.charts);
  const addChart = useChartStore((s) => s.addChart);

  const handleAddChart = () => {
    addChart({
      id: uuidv4(),
      type: "line",
      dataSourceId: mockDataSources[0].id,
      style: { colorScheme: "default", showLegend: true, showGrid: true },
    });
  };

  return (
    <Container sx={{ py: 4 }}>
      <Typography variant="h4" gutterBottom>
        å‹•æ…‹åœ–è¡¨è¨­å®šé¢æ¿
      </Typography>

      <Button variant="contained" onClick={handleAddChart} sx={{ mb: 2 }}>
        æ–°å¢åœ–è¡¨
      </Button>

      {charts.map((chart) => (
        <ChartConfigPanel
          key={chart.id}
          chartId={chart.id}
          dataSources={mockDataSources}
        />
      ))}
    </Container>
  );
}

export default App;
```

---

### 8. `main.tsx`

```tsx
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import CssBaseline from "@mui/material/CssBaseline";

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <CssBaseline />
    <App />
  </React.StrictMode>
);
```

---

âœ… å®Œæˆå¾Œï¼Œä½ å°±å¯ä»¥

* æŒ‰ã€Œæ–°å¢åœ–è¡¨ã€å»ºç«‹æ–°è¨­å®šé¢æ¿
* é¸æ“‡åœ–è¡¨é¡å‹ã€è³‡æ–™ä¾†æºã€æ¨£å¼
* ç‹€æ…‹å…¨éƒ¨å­˜åœ¨ **Zustand** ä¸­

---

è¦ä¸è¦æˆ‘å¹«ä½ å†è£œä¸€å€‹ **æ•´åˆ Recharts é¡¯ç¤ºå³æ™‚åœ–è¡¨çš„ç¯„ä¾‹**ï¼Œè®“ä½ ä¿®æ”¹è¨­å®šçš„åŒæ™‚ï¼Œå³é‚Šèƒ½å³æ™‚çœ‹åˆ°åœ–è¡¨æ•ˆæœï¼Ÿ

## ChatGPT å›ç­” æ•´åˆ Recharts é¡¯ç¤ºå³æ™‚åœ–è¡¨

å¤ªæ£’äº† ğŸ‰ é‚£æˆ‘å¹«ä½ æŠŠ **Recharts** æ•´åˆé€²ä¾†ï¼Œè®“è¨­å®šé¢æ¿ä¿®æ”¹çš„æ™‚å€™èƒ½å³æ™‚çœ‹åˆ°åœ–è¡¨æ•ˆæœã€‚é€™æ¨£ä½ çš„å„€è¡¨æ¿å°±æœ‰ã€Œè¨­å®šé¢æ¿ + é è¦½ã€åŠŸèƒ½ã€‚

---

### ğŸ“¦ éœ€è¦å®‰è£çš„å¥—ä»¶

åœ¨å°ˆæ¡ˆè£¡æ–°å¢ Rechartsï¼š

```bash
npm install recharts
```

---

### ğŸ“‚ æ–°å¢ä¸€å€‹å…ƒä»¶ `ChartPreview.tsx`

é€™å€‹å…ƒä»¶æœƒæ ¹æ“š `ChartConfig` å’Œå°æ‡‰çš„ `dataSource`ï¼Œå³æ™‚æ¸²æŸ“ä¸åŒé¡å‹çš„ Recharts åœ–è¡¨ã€‚

```tsx
import React from "react";
import {
  LineChart,
  Line,
  BarChart,
  Bar,
  PieChart,
  Pie,
  Cell,
  ScatterChart,
  Scatter,
  XAxis,
  YAxis,
  Tooltip,
  CartesianGrid,
  Legend,
} from "recharts";
import { ChartConfig, DataSource } from "../types";
import { Card, CardContent, Typography } from "@mui/material";

// æ¨¡æ“¬æ•¸æ“š (çœŸå¯¦æƒ…æ³æ‡‰è©²å¾ dataSource.url æŠ“å–æˆ– API è¼‰å…¥)
const mockData = [
  { name: "Jan", value: 400, users: 240 },
  { name: "Feb", value: 300, users: 139 },
  { name: "Mar", value: 200, users: 980 },
  { name: "Apr", value: 278, users: 390 },
  { name: "May", value: 189, users: 480 },
];

interface Props {
  config: ChartConfig;
  dataSource: DataSource | undefined;
}

export const ChartPreview: React.FC<Props> = ({ config, dataSource }) => {
  if (!dataSource) {
    return <Typography>âš ï¸ å°šæœªé¸æ“‡è³‡æ–™ä¾†æº</Typography>;
  }

  const { type, style } = config;

  const colors = {
    default: ["#8884d8", "#82ca9d"],
    dark: ["#333", "#666"],
    pastel: ["#ffb6b9", "#fae3d9"],
  };

  const colorSet = colors[style.colorScheme] || colors.default;

  return (
    <Card variant="outlined" sx={{ borderRadius: 2, mb: 2 }}>
      <CardContent>
        <Typography variant="subtitle1" gutterBottom>
          é è¦½ï¼š{type.toUpperCase()} ({dataSource.label})
        </Typography>

        {type === "line" && (
          <LineChart width={400} height={250} data={mockData}>
            {style.showGrid && <CartesianGrid strokeDasharray="3 3" />}
            <XAxis dataKey="name" />
            <YAxis />
            <Tooltip />
            {style.showLegend && <Legend />}
            <Line type="monotone" dataKey="value" stroke={colorSet[0]} />
            <Line type="monotone" dataKey="users" stroke={colorSet[1]} />
          </LineChart>
        )}

        {type === "bar" && (
          <BarChart width={400} height={250} data={mockData}>
            {style.showGrid && <CartesianGrid strokeDasharray="3 3" />}
            <XAxis dataKey="name" />
            <YAxis />
            <Tooltip />
            {style.showLegend && <Legend />}
            <Bar dataKey="value" fill={colorSet[0]} />
            <Bar dataKey="users" fill={colorSet[1]} />
          </BarChart>
        )}

        {type === "pie" && (
          <PieChart width={400} height={250}>
            <Tooltip />
            <Pie
              data={mockData}
              dataKey="value"
              nameKey="name"
              cx="50%"
              cy="50%"
              outerRadius={80}
              label
            >
              {mockData.map((_, i) => (
                <Cell key={i} fill={colorSet[i % colorSet.length]} />
              ))}
            </Pie>
          </PieChart>
        )}

        {type === "scatter" && (
          <ScatterChart width={400} height={250}>
            {style.showGrid && <CartesianGrid />}
            <XAxis dataKey="value" />
            <YAxis dataKey="users" />
            <Tooltip />
            {style.showLegend && <Legend />}
            <Scatter data={mockData} fill={colorSet[0]} />
          </ScatterChart>
        )}
      </CardContent>
    </Card>
  );
};
```

---

### ğŸ“‚ ä¿®æ”¹ `ChartConfigPanel.tsx`

åœ¨è¨­å®šé¢æ¿ä¸‹æ–¹åŠ ä¸Š **ChartPreview**ï¼Œè®“ç”¨æˆ¶é‚Šæ”¹é‚Šçœ‹æ•ˆæœã€‚

```tsx
import React from "react";
import { Card, CardContent, Typography } from "@mui/material";
import { useChartStore } from "../store/chartStore";
import { ChartTypeSelector } from "./ChartTypeSelector";
import { DataSourceSelector } from "./DataSourceSelector";
import { StyleConfigurator } from "./StyleConfigurator";
import { DataSource } from "../types";
import { ChartPreview } from "./ChartPreview";

interface Props {
  chartId: string;
  dataSources: DataSource[];
}

export const ChartConfigPanel: React.FC<Props> = ({ chartId, dataSources }) => {
  const chart = useChartStore((s) =>
    s.charts.find((c) => c.id === chartId)
  );
  const updateChart = useChartStore((s) => s.updateChart);

  if (!chart) return null;

  const dataSource = dataSources.find((d) => d.id === chart.dataSourceId);

  return (
    <Card variant="outlined" sx={{ borderRadius: 2, mb: 2 }}>
      <CardContent>
        <Typography variant="h6" gutterBottom>
          åœ–è¡¨è¨­å®š
        </Typography>

        <ChartTypeSelector
          value={chart.type}
          onChange={(type) => updateChart(chartId, { type })}
        />

        <DataSourceSelector
          value={chart.dataSourceId}
          dataSources={dataSources}
          onChange={(ds) => updateChart(chartId, { dataSourceId: ds })}
        />

        <StyleConfigurator
          style={chart.style}
          onChange={(style) => updateChart(chartId, { style })}
        />

        {/* å³æ™‚é è¦½ */}
        <ChartPreview config={chart} dataSource={dataSource} />
      </CardContent>
    </Card>
  );
};
```

---

### ğŸ“‚ `App.tsx`

åŸºæœ¬ä¸ç”¨å‹•ï¼Œåªæ˜¯ç¾åœ¨æ¯å€‹åœ–è¡¨éƒ½æœƒè‡ªå¸¶ä¸€å€‹é è¦½ã€‚

```tsx
import React from "react";
import { Button, Container, Typography } from "@mui/material";
import { useChartStore } from "./store/chartStore";
import { ChartConfigPanel } from "./components/ChartConfigPanel";
import { v4 as uuidv4 } from "uuid";

const mockDataSources = [
  { id: "1", label: "Sales Data", url: "/data/sales.json" },
  { id: "2", label: "User Growth", url: "/data/users.json" },
];

function App() {
  const charts = useChartStore((s) => s.charts);
  const addChart = useChartStore((s) => s.addChart);

  const handleAddChart = () => {
    addChart({
      id: uuidv4(),
      type: "line",
      dataSourceId: mockDataSources[0].id,
      style: { colorScheme: "default", showLegend: true, showGrid: true },
    });
  };

  return (
    <Container sx={{ py: 4 }}>
      <Typography variant="h4" gutterBottom>
        å‹•æ…‹åœ–è¡¨è¨­å®šé¢æ¿
      </Typography>

      <Button variant="contained" onClick={handleAddChart} sx={{ mb: 2 }}>
        æ–°å¢åœ–è¡¨
      </Button>

      {charts.map((chart) => (
        <ChartConfigPanel
          key={chart.id}
          chartId={chart.id}
          dataSources={mockDataSources}
        />
      ))}
    </Container>
  );
}

export default App;
```

---

âœ… å®Œæˆå¾Œæ•ˆæœï¼š

* æŒ‰ã€Œæ–°å¢åœ–è¡¨ã€ â†’ å»ºç«‹è¨­å®šé¢æ¿
* é¸æ“‡ä¸åŒåœ–è¡¨é¡å‹ â†’ ä¸‹æ–¹å³æ™‚é¡¯ç¤º Recharts é è¦½
* åˆ‡æ›æ¨£å¼ (Legend/Grid/ColorScheme) â†’ é è¦½ç«‹å³æ›´æ–°

---

è¦ä¸è¦æˆ‘å†å¹«ä½ å‡ç´šä¸€ä¸‹ï¼š
æŠŠ **mockData** æ”¹æˆçœŸçš„ **API / JSON æª”æ¡ˆå‹•æ…‹è¼‰å…¥**ï¼Œè®“ã€Œè³‡æ–™ä¾†æºã€çš„è¨­å®šçœŸæ­£ç™¼æ®ä½œç”¨ï¼Ÿ


## ChatGPT å›ç­” API / JSON æª”æ¡ˆå‹•æ…‹è¼‰å…¥

å¾ˆæ£’ï¼é‚£æˆ‘å€‘å°±æŠŠ **è³‡æ–™ä¾†æº (DataSource)** æ”¹æˆçœŸæ­£å¯å‹•æ…‹è¼‰å…¥ JSON / API è³‡æ–™ï¼Œè®“ã€Œè³‡æ–™ä¾†æºé¸æ“‡å™¨ã€ä¸åªæ˜¯è£é£¾ï¼Œè€Œæ˜¯çœŸæ­£å½±éŸ¿åœ–è¡¨å…§å®¹ã€‚

---

### ğŸ”„ è¨­è¨ˆæ€è·¯

1. **DataSource çµæ§‹**

   * æ¯å€‹è³‡æ–™ä¾†æºéƒ½æœ‰ä¸€å€‹ `url`ï¼Œå¯ä»¥æ˜¯ **æœ¬åœ° public è³‡æ–™æª”** æˆ– **å¤–éƒ¨ API**ã€‚
   * ä¾‹å¦‚ï¼š`/data/sales.json` æˆ– `https://api.example.com/users`.

2. **è³‡æ–™å¿«å–èˆ‡è¼‰å…¥**

   * æˆ‘å€‘ç”¨ `Zustand` æ–°å¢ä¸€å€‹ **dataStore**ï¼Œå°ˆé–€è™•ç†è³‡æ–™ä¾†æºçš„å¿«å–èˆ‡è«‹æ±‚ã€‚
   * é¸åˆ°æŸå€‹ `dataSourceId` æ™‚ï¼Œè‡ªå‹•å»æŠ“ `url` çš„è³‡æ–™ï¼Œå­˜åœ¨å¿«å–è£¡ã€‚

3. **ChartPreview æ”¹å‹•**

   * ä¸å†ç”¨ `mockData`ï¼Œè€Œæ˜¯æ ¹æ“š `dataSourceId` å» `dataStore` æ‹¿è³‡æ–™ã€‚
   * å¦‚æœé‚„åœ¨ loadingï¼Œå°±é¡¯ç¤º `CircularProgress`ã€‚
   * å¦‚æœéŒ¯èª¤ï¼Œé¡¯ç¤º `éŒ¯èª¤è¨Šæ¯`ã€‚

---

### ğŸ“‚ store/dataStore.ts

```ts
import { create } from "zustand";
import { DataSource } from "../types";

interface DataState {
  dataCache: Record<string, any[]>;
  loading: Record<string, boolean>;
  error: Record<string, string | null>;
  fetchData: (ds: DataSource) => Promise<void>;
}

export const useDataStore = create<DataState>((set, get) => ({
  dataCache: {},
  loading: {},
  error: {},
  fetchData: async (ds: DataSource) => {
    const { dataCache } = get();
    if (dataCache[ds.id]) return; // å·²æœ‰å¿«å–å°±ä¸å†æŠ“

    set((state) => ({
      loading: { ...state.loading, [ds.id]: true },
      error: { ...state.error, [ds.id]: null },
    }));

    try {
      const res = await fetch(ds.url);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const json = await res.json();

      set((state) => ({
        dataCache: { ...state.dataCache, [ds.id]: json },
        loading: { ...state.loading, [ds.id]: false },
      }));
    } catch (err: any) {
      set((state) => ({
        error: { ...state.error, [ds.id]: err.message },
        loading: { ...state.loading, [ds.id]: false },
      }));
    }
  },
}));
```

---

### ğŸ“‚ components/ChartPreview\.tsx

ä¿®æ”¹ç‚ºï¼š**æ ¹æ“š dataSourceId å–å¾—è³‡æ–™**ï¼Œä¸¦ç”¨ loading/error ç‹€æ…‹ä¾†é¡¯ç¤ºã€‚

```tsx
import React, { useEffect } from "react";
import {
  LineChart,
  Line,
  BarChart,
  Bar,
  PieChart,
  Pie,
  Cell,
  ScatterChart,
  Scatter,
  XAxis,
  YAxis,
  Tooltip,
  CartesianGrid,
  Legend,
} from "recharts";
import { ChartConfig, DataSource } from "../types";
import { Card, CardContent, Typography, CircularProgress } from "@mui/material";
import { useDataStore } from "../store/dataStore";

interface Props {
  config: ChartConfig;
  dataSource: DataSource | undefined;
}

export const ChartPreview: React.FC<Props> = ({ config, dataSource }) => {
  const { dataCache, loading, error, fetchData } = useDataStore();

  useEffect(() => {
    if (dataSource) {
      fetchData(dataSource);
    }
  }, [dataSource]);

  if (!dataSource) {
    return <Typography>âš ï¸ å°šæœªé¸æ“‡è³‡æ–™ä¾†æº</Typography>;
  }

  const data = dataCache[dataSource.id];
  const isLoading = loading[dataSource.id];
  const err = error[dataSource.id];

  if (isLoading) return <CircularProgress />;
  if (err) return <Typography color="error">âŒ è¼‰å…¥å¤±æ•—: {err}</Typography>;
  if (!data) return <Typography>ç­‰å¾…è¼‰å…¥è³‡æ–™...</Typography>;

  const { type, style } = config;

  const colors = {
    default: ["#8884d8", "#82ca9d"],
    dark: ["#333", "#666"],
    pastel: ["#ffb6b9", "#fae3d9"],
  };
  const colorSet = colors[style.colorScheme] || colors.default;

  return (
    <Card variant="outlined" sx={{ borderRadius: 2, mt: 2 }}>
      <CardContent>
        <Typography variant="subtitle1" gutterBottom>
          é è¦½ï¼š{type.toUpperCase()} ({dataSource.label})
        </Typography>

        {type === "line" && (
          <LineChart width={400} height={250} data={data}>
            {style.showGrid && <CartesianGrid strokeDasharray="3 3" />}
            <XAxis dataKey="name" />
            <YAxis />
            <Tooltip />
            {style.showLegend && <Legend />}
            <Line type="monotone" dataKey="value" stroke={colorSet[0]} />
            <Line type="monotone" dataKey="users" stroke={colorSet[1]} />
          </LineChart>
        )}

        {type === "bar" && (
          <BarChart width={400} height={250} data={data}>
            {style.showGrid && <CartesianGrid strokeDasharray="3 3" />}
            <XAxis dataKey="name" />
            <YAxis />
            <Tooltip />
            {style.showLegend && <Legend />}
            <Bar dataKey="value" fill={colorSet[0]} />
            <Bar dataKey="users" fill={colorSet[1]} />
          </BarChart>
        )}

        {type === "pie" && (
          <PieChart width={400} height={250}>
            <Tooltip />
            <Pie
              data={data}
              dataKey="value"
              nameKey="name"
              cx="50%"
              cy="50%"
              outerRadius={80}
              label
            >
              {data.map((_: any, i: number) => (
                <Cell key={i} fill={colorSet[i % colorSet.length]} />
              ))}
            </Pie>
          </PieChart>
        )}

        {type === "scatter" && (
          <ScatterChart width={400} height={250}>
            {style.showGrid && <CartesianGrid />}
            <XAxis dataKey="value" />
            <YAxis dataKey="users" />
            <Tooltip />
            {style.showLegend && <Legend />}
            <Scatter data={data} fill={colorSet[0]} />
          </ScatterChart>
        )}
      </CardContent>
    </Card>
  );
};
```

---

### ğŸ“‚ public/data/sales.json (ç¯„ä¾‹è³‡æ–™)

```json
[
  { "name": "Jan", "value": 400, "users": 240 },
  { "name": "Feb", "value": 300, "users": 139 },
  { "name": "Mar", "value": 200, "users": 980 },
  { "name": "Apr", "value": 278, "users": 390 },
  { "name": "May", "value": 189, "users": 480 }
]
```

---

### ğŸ“‚ App.tsx (åªè¦ç¶­æŒä¸€æ¨£)

```tsx
const mockDataSources = [
  { id: "1", label: "Sales Data", url: "/data/sales.json" },
  { id: "2", label: "User Growth", url: "/data/users.json" },
];
```

---

âœ… ç¾åœ¨æ•ˆæœï¼š

* é¸åˆ°æŸå€‹è³‡æ–™ä¾†æºæ™‚ï¼Œæœƒå» `fetch` å…¶ `url` (ä¸€æ¬¡è¼‰å…¥ä¸¦å¿«å–)ã€‚
* é è¦½åœ–è¡¨æœƒé¡¯ç¤ºçœŸå¯¦ JSON è³‡æ–™å…§å®¹ã€‚
* ä¸‹æ¬¡åˆ‡æ›å›åŒå€‹è³‡æ–™ä¾†æºï¼Œä¸æœƒé‡è¤‡æŠ“è³‡æ–™ã€‚

---

è¦ä¸è¦æˆ‘å†å¹«ä½ åŠ ä¸€å€‹åŠŸèƒ½ï¼š**æ”¯æ´è‡ªå‹•é‡æ–°æ•´ç† (Polling)**ï¼Œä¾‹å¦‚æ¯ 30 ç§’é‡æ–°æŠ“ä¸€æ¬¡ API è³‡æ–™ï¼Œé©åˆåšå³æ™‚å„€è¡¨æ¿ï¼Ÿ


## ChatGPT å›ç­” æ”¯æ´è‡ªå‹•é‡æ–°æ•´ç† (Polling)
å®Œç¾ ğŸš€ é‚£æˆ‘å€‘ä¾†å‡ç´šè³‡æ–™ä¾†æºç³»çµ±ï¼Œæ”¯æ´ **è‡ªå‹•é‡æ–°æ•´ç† (Polling)** åŠŸèƒ½ã€‚é€™æ¨£å°±èƒ½åšåˆ°åƒã€Œå³æ™‚å„€è¡¨æ¿ã€ä¸€æ¨£ï¼Œå®šæ™‚æ›´æ–°åœ–è¡¨æ•¸æ“šã€‚

---

### ğŸ”„ è¨­è¨ˆæ€è·¯

1. åœ¨ `DataSource` åŠ ä¸Šå¯é¸åƒæ•¸ `refreshInterval` (æ¯«ç§’)ã€‚
2. åœ¨ `dataStore` ä½¿ç”¨ `setInterval`ï¼Œä¾æ“šä¸åŒ `DataSource` çš„è¨­å®šé€±æœŸå»é‡æ–°æŠ“è³‡æ–™ã€‚
3. é è¦½ (`ChartPreview`) è‡ªå‹•è·Ÿéš¨æ›´æ–°ï¼Œä¸éœ€è¦é¡å¤–æ”¹å‹•ï¼Œå› ç‚ºæ•¸æ“šæ›´æ–°æœƒé€é `Zustand` è§¸ç™¼ re-renderã€‚

---

### ğŸ“‚ ä¿®æ”¹ `types.ts`

```ts
export interface DataSource {
  id: string;
  label: string;
  url: string;
  refreshInterval?: number; // æ¯«ç§’ (ä¾‹ï¼š30000 = 30 ç§’)
}
```

---

### ğŸ“‚ ä¿®æ”¹ `store/dataStore.ts`

æˆ‘å€‘åœ¨ `fetchData` è£¡å•Ÿå‹•ä¸€å€‹ pollingï¼Œä¸¦è¨˜éŒ„ timerï¼Œé¿å…é‡è¤‡è¨­å®šã€‚

```ts
import { create } from "zustand";
import { DataSource } from "../types";

interface DataState {
  dataCache: Record<string, any[]>;
  loading: Record<string, boolean>;
  error: Record<string, string | null>;
  timers: Record<string, number>; // å­˜æ”¾ setInterval ID
  fetchData: (ds: DataSource) => Promise<void>;
}

export const useDataStore = create<DataState>((set, get) => ({
  dataCache: {},
  loading: {},
  error: {},
  timers: {},
  fetchData: async (ds: DataSource) => {
    const { dataCache, timers } = get();

    // å¦‚æœå·²ç¶“åœ¨ pollingï¼Œå°±ç›´æ¥å›å‚³
    if (timers[ds.id]) return;

    const load = async () => {
      set((state) => ({
        loading: { ...state.loading, [ds.id]: true },
        error: { ...state.error, [ds.id]: null },
      }));

      try {
        const res = await fetch(ds.url + `?t=${Date.now()}`); // åŠ  timestamp é˜²å¿«å–
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const json = await res.json();

        set((state) => ({
          dataCache: { ...state.dataCache, [ds.id]: json },
          loading: { ...state.loading, [ds.id]: false },
        }));
      } catch (err: any) {
        set((state) => ({
          error: { ...state.error, [ds.id]: err.message },
          loading: { ...state.loading, [ds.id]: false },
        }));
      }
    };

    // ç«‹å³è¼‰å…¥ä¸€æ¬¡
    await load();

    // å¦‚æœæœ‰ refreshIntervalï¼Œå°±å•Ÿå‹•è¼ªè©¢
    if (ds.refreshInterval) {
      const timerId = window.setInterval(load, ds.refreshInterval);
      set((state) => ({
        timers: { ...state.timers, [ds.id]: timerId },
      }));
    }
  },
}));
```

---

### ğŸ“‚ ä¿®æ”¹ `App.tsx`

ç¾åœ¨ä½ å¯ä»¥çµ¦ä¸åŒ `DataSource` è¨­å®š refreshIntervalï¼Œä¾‹å¦‚ 30 ç§’åˆ·æ–°ã€‚

```tsx
const mockDataSources = [
  { id: "1", label: "Sales Data", url: "/data/sales.json", refreshInterval: 30000 },
  { id: "2", label: "User Growth", url: "/data/users.json", refreshInterval: 10000 },
];
```

---

### ğŸ“‚ ChartPreview\.tsx (ä¸ç”¨å¤§æ”¹)

å”¯ä¸€å°èª¿æ•´ï¼šç‚ºäº†é˜²æ­¢ã€Œåˆ‡æ› dataSourceã€æ™‚ä¸æœƒè§¸ç™¼ reloadï¼Œå¯ä»¥ç¢ºä¿æ¯æ¬¡ dataSource è®Šå‹•éƒ½æœƒå‘¼å« fetchDataã€‚

```tsx
useEffect(() => {
  if (dataSource) {
    fetchData(dataSource);
  }
}, [dataSource?.id]); // æ³¨æ„ç›£è½ id
```

---

### âœ… æ•ˆæœ

* `Sales Data` æœƒæ¯ **30 ç§’** è‡ªå‹•æ›´æ–°ã€‚
* `User Growth` æœƒæ¯ **10 ç§’** è‡ªå‹•æ›´æ–°ã€‚
* ChartPreview ä¸éœ€è¦ä»»ä½•é¡å¤–æ“ä½œï¼Œå°±èƒ½å³æ™‚çœ‹åˆ°æ›´æ–°æ•¸æ“šã€‚
* å¦‚æœ API æ”¯æ´å³æ™‚è³‡æ–™ï¼Œé€™å°±æ˜¯ä¸€å€‹å°å‹çš„ **å¯¦æ™‚å„€è¡¨æ¿**ï¼

---

è¦ä¸è¦æˆ‘å†å¹«ä½ åŠ å€‹ UI æ§åˆ¶ï¼š
åœ¨ **ChartConfigPanel** è£¡è®“ä½¿ç”¨è€…è‡ªå·±è¨­å®šã€Œåˆ·æ–°é–“éš”ã€(å¯è¼¸å…¥ç§’æ•¸)ï¼Œä¸¦å³æ™‚ç”Ÿæ•ˆï¼Ÿ


## ChatGPT å›ç­” ä½¿ç”¨è€…è‡ªå·±è¨­å®šã€Œåˆ·æ–°é–“éš”ã€(å¯è¼¸å…¥ç§’æ•¸)

å¤ªå¥½äº† ğŸ™Œ æˆ‘å€‘ç¾åœ¨ä¾†è®“ **ä½¿ç”¨è€…èƒ½åœ¨ ChartConfigPanel ä¸­è‡ªå·±è¨­å®šã€Œåˆ·æ–°é–“éš” (Polling Interval)ã€**ï¼Œé€™æ¨£å°±èƒ½è‡ªç”±æ§åˆ¶æ¯å€‹åœ–è¡¨çš„æ›´æ–°é »ç‡ã€‚

---

### ğŸ”„ è¨­è¨ˆæ€è·¯

1. åœ¨ `ChartConfig` æ–°å¢ `refreshInterval` å±¬æ€§ã€‚
2. åœ¨ `ChartConfigPanel` å¢åŠ ä¸€å€‹è¼¸å…¥æ¬„ä½ (MUI `TextField` æˆ– `Select`) è®“ä½¿ç”¨è€…è¨­å®šåˆ·æ–°é–“éš”ï¼ˆä»¥ç§’ç‚ºå–®ä½ï¼‰ã€‚
3. ç•¶ä½¿ç”¨è€…ä¿®æ”¹æ™‚ï¼Œæœƒæ›´æ–° `chart.refreshInterval`ï¼Œä¸¦ç”± `ChartPreview` é€šçŸ¥ `dataStore` å•Ÿå‹•æˆ–æ›´æ–°è¼ªè©¢ã€‚

---

### ğŸ“‚ ä¿®æ”¹ `types.ts`

```ts
export interface ChartConfig {
  id: string;
  type: ChartType;
  dataSourceId: string;
  style: ChartStyle;
  refreshInterval?: number; // æ¯«ç§’ (ä¾‹ï¼š30000 = 30 ç§’)
}
```

---

### ğŸ“‚ ä¿®æ”¹ `ChartConfigPanel.tsx`

åœ¨è¨­å®šé¢æ¿ä¸­æ–°å¢ã€Œåˆ·æ–°é–“éš” (ç§’)ã€è¼¸å…¥æ¬„ä½ã€‚

```tsx
import React from "react";
import {
  Card,
  CardContent,
  Typography,
  TextField,
} from "@mui/material";
import { useChartStore } from "../store/chartStore";
import { ChartTypeSelector } from "./ChartTypeSelector";
import { DataSourceSelector } from "./DataSourceSelector";
import { StyleConfigurator } from "./StyleConfigurator";
import { DataSource } from "../types";
import { ChartPreview } from "./ChartPreview";

interface Props {
  chartId: string;
  dataSources: DataSource[];
}

export const ChartConfigPanel: React.FC<Props> = ({ chartId, dataSources }) => {
  const chart = useChartStore((s) =>
    s.charts.find((c) => c.id === chartId)
  );
  const updateChart = useChartStore((s) => s.updateChart);

  if (!chart) return null;

  const dataSource = dataSources.find((d) => d.id === chart.dataSourceId);

  return (
    <Card variant="outlined" sx={{ borderRadius: 2, mb: 2 }}>
      <CardContent>
        <Typography variant="h6" gutterBottom>
          åœ–è¡¨è¨­å®š
        </Typography>

        <ChartTypeSelector
          value={chart.type}
          onChange={(type) => updateChart(chartId, { type })}
        />

        <DataSourceSelector
          value={chart.dataSourceId}
          dataSources={dataSources}
          onChange={(ds) => updateChart(chartId, { dataSourceId: ds })}
        />

        <StyleConfigurator
          style={chart.style}
          onChange={(style) => updateChart(chartId, { style })}
        />

        {/* ğŸ”„ æ–°å¢åˆ·æ–°é–“éš”è¨­å®š */}
        <TextField
          label="åˆ·æ–°é–“éš” (ç§’)"
          type="number"
          fullWidth
          margin="normal"
          value={(chart.refreshInterval ?? 0) / 1000}
          onChange={(e) => {
            const seconds = parseInt(e.target.value, 10);
            updateChart(chartId, {
              refreshInterval: seconds > 0 ? seconds * 1000 : undefined,
            });
          }}
        />

        {/* å³æ™‚é è¦½ */}
        <ChartPreview config={chart} dataSource={dataSource} />
      </CardContent>
    </Card>
  );
};
```

---

### ğŸ“‚ ä¿®æ”¹ `ChartPreview.tsx`

è®“å®ƒç›£è½ `config.refreshInterval`ï¼Œä¸¦å‚³çµ¦ `fetchData`ã€‚

```tsx
useEffect(() => {
  if (dataSource) {
    fetchData({ ...dataSource, refreshInterval: config.refreshInterval });
  }
}, [dataSource?.id, config.refreshInterval]);
```

---

### ğŸ“‚ ä¿®æ”¹ `store/dataStore.ts`

éœ€è¦åŠ ä¸€é»é‚è¼¯ï¼š
ç•¶ä½¿ç”¨è€…èª¿æ•´ `refreshInterval` æ™‚ï¼Œè¦æ¸…é™¤èˆŠçš„ timerï¼Œé‡æ–°è¨­å®šã€‚

```ts
export const useDataStore = create<DataState>((set, get) => ({
  dataCache: {},
  loading: {},
  error: {},
  timers: {},
  fetchData: async (ds: DataSource) => {
    const { timers } = get();

    // å¦‚æœå·²ç¶“æœ‰ timerï¼Œå°±æ¸…æ‰ (é¿å…é‡è¤‡)
    if (timers[ds.id]) {
      clearInterval(timers[ds.id]);
      set((state) => {
        const newTimers = { ...state.timers };
        delete newTimers[ds.id];
        return { timers: newTimers };
      });
    }

    const load = async () => {
      set((state) => ({
        loading: { ...state.loading, [ds.id]: true },
        error: { ...state.error, [ds.id]: null },
      }));

      try {
        const res = await fetch(ds.url + `?t=${Date.now()}`);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const json = await res.json();

        set((state) => ({
          dataCache: { ...state.dataCache, [ds.id]: json },
          loading: { ...state.loading, [ds.id]: false },
        }));
      } catch (err: any) {
        set((state) => ({
          error: { ...state.error, [ds.id]: err.message },
          loading: { ...state.loading, [ds.id]: false },
        }));
      }
    };

    // ç«‹å³è¼‰å…¥ä¸€æ¬¡
    await load();

    // å¦‚æœæœ‰ refreshIntervalï¼Œå°±å•Ÿå‹•è¼ªè©¢
    if (ds.refreshInterval) {
      const timerId = window.setInterval(load, ds.refreshInterval);
      set((state) => ({
        timers: { ...state.timers, [ds.id]: timerId },
      }));
    }
  },
}));
```

---

### âœ… ç¾åœ¨çš„æ•ˆæœ

* æ¯å€‹åœ–è¡¨çš„è¨­å®šé¢æ¿éƒ½æœ‰ã€Œåˆ·æ–°é–“éš” (ç§’)ã€è¼¸å…¥æ¡†ã€‚
* é è¨­å€¼ 0 = ä¸è‡ªå‹•åˆ·æ–°ã€‚
* ä½¿ç”¨è€…è¼¸å…¥æ•¸å­—å¾Œï¼Œæœƒç«‹å³æ›´æ–°è¼ªè©¢é »ç‡ã€‚
* åˆ‡æ›ä¸åŒåœ–è¡¨ï¼Œåˆ·æ–°é–“éš”å¯ä»¥ä¸åŒã€‚

---

è¦ä¸è¦æˆ‘å†å¹«ä½ åŠ ä¸€å€‹åŠŸèƒ½ï¼š**è®“ä½¿ç”¨è€…å¯ä»¥å³æ™‚é¸æ“‡è¦é¡¯ç¤ºå“ªäº›æ•¸æ“šæ¬„ä½ (ex: value / users / revenue)**ï¼Œé€™æ¨£åœ–è¡¨å°±èƒ½æ›´å½ˆæ€§ï¼Ÿ


## ChatGPT å›ç­” è®“ä½¿ç”¨è€…å¯ä»¥å³æ™‚é¸æ“‡è¦é¡¯ç¤ºå“ªäº›æ•¸æ“šæ¬„ä½ (ex: value / users / revenue)

ğŸ‘Œ å¥½ä¸»æ„ï¼æˆ‘å€‘ä¾†åŠ ä¸Š **ã€Œæ¬„ä½é¸æ“‡å™¨ (Field Selector)ã€**ï¼Œè®“ä½¿ç”¨è€…èƒ½å³æ™‚æ±ºå®šè¦åœ¨åœ–è¡¨ä¸Šé¡¯ç¤ºå“ªäº›æ•¸æ“šæ¬„ä½ã€‚

é€™åŠŸèƒ½å°å¤šç¶­åº¦è³‡æ–™ (ä¾‹å¦‚ `value`, `users`, `revenue`) ç‰¹åˆ¥æœ‰ç”¨ã€‚

---

### ğŸ”„ è¨­è¨ˆæ€è·¯

1. åœ¨ `ChartConfig` å¢åŠ  `fields: string[]`ï¼Œå­˜æ”¾ä½¿ç”¨è€…é¸æ“‡çš„æ¬„ä½ã€‚
2. åœ¨ `ChartConfigPanel` åŠ ä¸Š **å¤šé¸ä¸‹æ‹‰é¸å–® (MUI Select with multiple)**ï¼Œå‹•æ…‹åˆ—å‡ºå¯ç”¨æ¬„ä½ã€‚
3. `ChartPreview` æ ¹æ“š `fields` æ¸²æŸ“å°æ‡‰çš„æ•¸æ“šç·š/æŸ±ç‹€ã€‚
4. æ¬„ä½çš„å€™é¸æ¸…å–®å¯ä»¥æ ¹æ“š **è³‡æ–™ä¾†æºç¬¬ä¸€ç­†è³‡æ–™çš„ keys** è‡ªå‹•æ¨æ–·ã€‚

---

### ğŸ“‚ ä¿®æ”¹ `types.ts`

```ts
export interface ChartConfig {
  id: string;
  type: ChartType;
  dataSourceId: string;
  style: ChartStyle;
  refreshInterval?: number;
  fields?: string[]; // è¦é¡¯ç¤ºçš„æ•¸æ“šæ¬„ä½
}
```

---

### ğŸ“‚ æ–°å¢ `FieldSelector.tsx`

```tsx
import React from "react";
import { FormControl, InputLabel, Select, MenuItem, Checkbox, ListItemText } from "@mui/material";

interface Props {
  availableFields: string[];
  selectedFields: string[];
  onChange: (fields: string[]) => void;
}

export const FieldSelector: React.FC<Props> = ({
  availableFields,
  selectedFields,
  onChange,
}) => {
  return (
    <FormControl fullWidth margin="normal">
      <InputLabel>é¡¯ç¤ºæ¬„ä½</InputLabel>
      <Select
        multiple
        value={selectedFields}
        onChange={(e) => onChange(e.target.value as string[])}
        renderValue={(selected) => (selected as string[]).join(", ")}
      >
        {availableFields.map((field) => (
          <MenuItem key={field} value={field}>
            <Checkbox checked={selectedFields.includes(field)} />
            <ListItemText primary={field} />
          </MenuItem>
        ))}
      </Select>
    </FormControl>
  );
};
```

---

### ğŸ“‚ ä¿®æ”¹ `ChartConfigPanel.tsx`

åŠ å…¥ `FieldSelector`ï¼Œæ¬„ä½ä¾†æºä¾†è‡ª `dataStore.dataCache`ã€‚

```tsx
import { FieldSelector } from "./FieldSelector";
import { useDataStore } from "../store/dataStore";

export const ChartConfigPanel: React.FC<Props> = ({ chartId, dataSources }) => {
  const chart = useChartStore((s) =>
    s.charts.find((c) => c.id === chartId)
  );
  const updateChart = useChartStore((s) => s.updateChart);
  const dataCache = useDataStore((s) => s.dataCache);

  if (!chart) return null;

  const dataSource = dataSources.find((d) => d.id === chart.dataSourceId);
  const rawData = dataSource ? dataCache[dataSource.id] : [];
  const availableFields = rawData && rawData.length > 0
    ? Object.keys(rawData[0]).filter((k) => k !== "name") // æ’é™¤ X è»¸
    : [];

  return (
    <Card variant="outlined" sx={{ borderRadius: 2, mb: 2 }}>
      <CardContent>
        <Typography variant="h6" gutterBottom>
          åœ–è¡¨è¨­å®š
        </Typography>

        {/* å·²æœ‰çš„è¨­å®šå€‘ */}
        <ChartTypeSelector
          value={chart.type}
          onChange={(type) => updateChart(chartId, { type })}
        />
        <DataSourceSelector
          value={chart.dataSourceId}
          dataSources={dataSources}
          onChange={(ds) => updateChart(chartId, { dataSourceId: ds })}
        />
        <StyleConfigurator
          style={chart.style}
          onChange={(style) => updateChart(chartId, { style })}
        />

        {/* æ–°å¢æ¬„ä½é¸æ“‡å™¨ */}
        <FieldSelector
          availableFields={availableFields}
          selectedFields={chart.fields ?? []}
          onChange={(fields) => updateChart(chartId, { fields })}
        />

        {/* åˆ·æ–°é–“éš” */}
        <TextField
          label="åˆ·æ–°é–“éš” (ç§’)"
          type="number"
          fullWidth
          margin="normal"
          value={(chart.refreshInterval ?? 0) / 1000}
          onChange={(e) => {
            const seconds = parseInt(e.target.value, 10);
            updateChart(chartId, {
              refreshInterval: seconds > 0 ? seconds * 1000 : undefined,
            });
          }}
        />

        {/* é è¦½ */}
        <ChartPreview config={chart} dataSource={dataSource} />
      </CardContent>
    </Card>
  );
};
```

---

### ğŸ“‚ ä¿®æ”¹ `ChartPreview.tsx`

æ ¹æ“š `config.fields` å‹•æ…‹ç¹ªè£½åœ–è¡¨ã€‚

```tsx
{config.type === "line" && (
  <LineChart data={data} margin={{ top: 5, right: 20, bottom: 5, left: 0 }}>
    <CartesianGrid strokeDasharray="3 3" />
    <XAxis dataKey="name" />
    <YAxis />
    <Tooltip />
    <Legend />
    {(config.fields ?? []).map((f) => (
      <Line key={f} type="monotone" dataKey={f} stroke={config.style.color} />
    ))}
  </LineChart>
)}

{config.type === "bar" && (
  <BarChart data={data} margin={{ top: 5, right: 20, bottom: 5, left: 0 }}>
    <CartesianGrid strokeDasharray="3 3" />
    <XAxis dataKey="name" />
    <YAxis />
    <Tooltip />
    <Legend />
    {(config.fields ?? []).map((f) => (
      <Bar key={f} dataKey={f} fill={config.style.color} />
    ))}
  </BarChart>
)}
```

---

### âœ… æœ€çµ‚æ•ˆæœ

* ä½¿ç”¨è€…é¸å¥½è³‡æ–™ä¾†æºå¾Œï¼Œç³»çµ±æœƒè‡ªå‹•åµæ¸¬å¯ç”¨æ¬„ä½ (ex: `value`, `users`, `revenue`)ã€‚
* åœ¨ã€Œæ¬„ä½é¸æ“‡å™¨ã€ä¸­å¯å¤šé¸æ¬„ä½ã€‚
* é è¦½å€æœƒå³æ™‚æ›´æ–°ï¼Œåªé¡¯ç¤ºå‹¾é¸çš„æ•¸æ“šç·šæˆ–æŸ±ç‹€ã€‚
* æ¯å€‹åœ–è¡¨å¯ä»¥æœ‰ä¸åŒæ¬„ä½è¨­å®šã€‚

---

è¦ä¸è¦æˆ‘å†å¹«ä½ åŠ å€‹ **æ¬„ä½é¡è‰²è‡ªè¨‚åŠŸèƒ½ (æ¯å€‹æ¬„ä½ä¸åŒé¡è‰²)**ï¼Œè®“å¤šç·šåœ–æ›´æ¸…æ™°ï¼Ÿ


## ChatGPT å›ç­” æ¬„ä½é¡è‰²è‡ªè¨‚åŠŸèƒ½ (æ¯å€‹æ¬„ä½ä¸åŒé¡è‰²)

## ChatGPT å›ç­” 

## ChatGPT å›ç­” 